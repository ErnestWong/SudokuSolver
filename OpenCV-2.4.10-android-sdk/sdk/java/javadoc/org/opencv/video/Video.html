<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.6.0_32) on Wed Oct 01 12:52:03 MSK 2014 -->
<title>Video</title>
<meta name="date" content="2014-10-01">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Video";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>OpenCV 2.4.10</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/opencv/video/KalmanFilter.html" title="class in org.opencv.video"><span class="strong">PREV CLASS</span></a></li>
<li>NEXT CLASS</li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/video/Video.html" target="_top">FRAMES</a></li>
<li><a href="Video.html" target="_top">NO FRAMES</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>SUMMARY:&nbsp;</li>
<li>NESTED&nbsp;|&nbsp;</li>
<li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">METHOD</a></li>
</ul>
<ul class="subNavList">
<li>DETAIL:&nbsp;</li>
<li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">METHOD</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<p class="subTitle">org.opencv.video</p>
<h2 title="Class Video" class="title">Class Video</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.opencv.video.Video</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <strong>Video</strong>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#OPTFLOW_FARNEBACK_GAUSSIAN">OPTFLOW_FARNEBACK_GAUSSIAN</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#OPTFLOW_LK_GET_MIN_EIGENVALS">OPTFLOW_LK_GET_MIN_EIGENVALS</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#OPTFLOW_USE_INITIAL_FLOW">OPTFLOW_USE_INITIAL_FLOW</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../org/opencv/video/Video.html#Video()">Video</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int)">buildOpticalFlowPyramid</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                       java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
                       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                       int&nbsp;maxLevel)</code>
<div class="block">Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int, boolean, int, int, boolean)">buildOpticalFlowPyramid</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                       java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
                       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                       int&nbsp;maxLevel,
                       boolean&nbsp;withDerivatives,
                       int&nbsp;pyrBorder,
                       int&nbsp;derivBorder,
                       boolean&nbsp;tryReuseInputImage)</code>
<div class="block">Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcGlobalOrientation(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">calcGlobalOrientation</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                     double&nbsp;timestamp,
                     double&nbsp;duration)</code>
<div class="block">Calculates a global motion orientation in a selected region.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">calcMotionGradient</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                  double&nbsp;delta1,
                  double&nbsp;delta2)</code>
<div class="block">Calculates a gradient orientation of a motion history image.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">calcMotionGradient</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                  double&nbsp;delta1,
                  double&nbsp;delta2,
                  int&nbsp;apertureSize)</code>
<div class="block">Calculates a gradient orientation of a motion history image.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcOpticalFlowFarneback(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, int, double, int)">calcOpticalFlowFarneback</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prev,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;next,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                        double&nbsp;pyr_scale,
                        int&nbsp;levels,
                        int&nbsp;winsize,
                        int&nbsp;iterations,
                        int&nbsp;poly_n,
                        double&nbsp;poly_sigma,
                        int&nbsp;flags)</code>
<div class="block">Computes a dense optical flow using the Gunnar Farneback's algorithm.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat)">calcOpticalFlowPyrLK</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                    <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                    <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                    <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                    <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err)</code>
<div class="block">Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int)">calcOpticalFlowPyrLK</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                    <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                    <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                    <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                    <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
                    <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                    int&nbsp;maxLevel)</code>
<div class="block">Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)">calcOpticalFlowPyrLK</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                    <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                    <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                    <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                    <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
                    <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                    int&nbsp;maxLevel,
                    <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                    int&nbsp;flags,
                    double&nbsp;minEigThreshold)</code>
<div class="block">Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">calcOpticalFlowSF</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                 int&nbsp;layers,
                 int&nbsp;averaging_block_size,
                 int&nbsp;max_flow)</code>
<div class="block">Calculate an optical flow using "SimpleFlow" algorithm.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int, double, double, double, int, double, double, double)">calcOpticalFlowSF</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                 int&nbsp;layers,
                 int&nbsp;averaging_block_size,
                 int&nbsp;max_flow,
                 double&nbsp;sigma_dist,
                 double&nbsp;sigma_color,
                 int&nbsp;postprocess_window,
                 double&nbsp;sigma_dist_fix,
                 double&nbsp;sigma_color_fix,
                 double&nbsp;occ_thr,
                 int&nbsp;upscale_averaging_radius,
                 double&nbsp;upscale_sigma_dist,
                 double&nbsp;upscale_sigma_color,
                 double&nbsp;speed_up_thr)</code>
<div class="block">Calculate an optical flow using "SimpleFlow" algorithm.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#CamShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">CamShift</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;probImage,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Finds an object center, size, and orientation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)">estimateRigidTransform</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                      boolean&nbsp;fullAffine)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#meanShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">meanShift</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;probImage,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
         <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Finds an object on a back projection image.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#segmentMotion(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfRect, double, double)">segmentMotion</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;segmask,
             <a href="../../../org/opencv/core/MatOfRect.html" title="class in org.opencv.core">MatOfRect</a>&nbsp;boundingRects,
             double&nbsp;timestamp,
             double&nbsp;segThresh)</code>
<div class="block">Splits a motion history image into a few parts corresponding to separate
 independent motions (for example, left hand, right hand).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../org/opencv/video/Video.html#updateMotionHistory(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">updateMotionHistory</a></strong>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;silhouette,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                   double&nbsp;timestamp,
                   double&nbsp;duration)</code>
<div class="block">Updates the motion history image by a moving silhouette.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="OPTFLOW_FARNEBACK_GAUSSIAN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OPTFLOW_FARNEBACK_GAUSSIAN</h4>
<pre>public static final&nbsp;int OPTFLOW_FARNEBACK_GAUSSIAN</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_FARNEBACK_GAUSSIAN">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="OPTFLOW_LK_GET_MIN_EIGENVALS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OPTFLOW_LK_GET_MIN_EIGENVALS</h4>
<pre>public static final&nbsp;int OPTFLOW_LK_GET_MIN_EIGENVALS</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_LK_GET_MIN_EIGENVALS">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="OPTFLOW_USE_INITIAL_FLOW">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>OPTFLOW_USE_INITIAL_FLOW</h4>
<pre>public static final&nbsp;int OPTFLOW_USE_INITIAL_FLOW</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_USE_INITIAL_FLOW">Constant Field Values</a></dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Video()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Video</h4>
<pre>public&nbsp;Video()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildOpticalFlowPyramid</h4>
<pre>public static&nbsp;int&nbsp;buildOpticalFlowPyramid(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                          java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
                          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                          int&nbsp;maxLevel)</pre>
<div class="block"><p>Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>img</code> - 8-bit input image.</dd><dd><code>pyramid</code> - output pyramid.</dd><dd><code>winSize</code> - window size of optical flow algorithm. Must be not less than
 <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to
 calculate required padding for pyramid levels.</dd><dd><code>maxLevel</code> - 0-based maximal pyramid level number.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a></dd></dl>
</li>
</ul>
<a name="buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int, boolean, int, int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildOpticalFlowPyramid</h4>
<pre>public static&nbsp;int&nbsp;buildOpticalFlowPyramid(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                          java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
                          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                          int&nbsp;maxLevel,
                          boolean&nbsp;withDerivatives,
                          int&nbsp;pyrBorder,
                          int&nbsp;derivBorder,
                          boolean&nbsp;tryReuseInputImage)</pre>
<div class="block"><p>Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>img</code> - 8-bit input image.</dd><dd><code>pyramid</code> - output pyramid.</dd><dd><code>winSize</code> - window size of optical flow algorithm. Must be not less than
 <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to
 calculate required padding for pyramid levels.</dd><dd><code>maxLevel</code> - 0-based maximal pyramid level number.</dd><dd><code>withDerivatives</code> - set to precompute gradients for the every pyramid
 level. If pyramid is constructed without the gradients then "calcOpticalFlowPyrLK"
 will calculate them internally.</dd><dd><code>pyrBorder</code> - the border mode for pyramid layers.</dd><dd><code>derivBorder</code> - the border mode for gradients.</dd><dd><code>tryReuseInputImage</code> - put ROI of input image into the pyramid if
 possible. You can pass <code>false</code> to force data copying.

 <p>:return: number of levels in constructed pyramid. Can be less than
 <code>maxLevel</code>.</p></dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a></dd></dl>
</li>
</ul>
<a name="calcGlobalOrientation(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcGlobalOrientation</h4>
<pre>public static&nbsp;double&nbsp;calcGlobalOrientation(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                           double&nbsp;timestamp,
                           double&nbsp;duration)</pre>
<div class="block"><p>Calculates a global motion orientation in a selected region.</p>

 <p>The function calculates an average motion direction in the selected region
 and returns the angle between 0 degrees and 360 degrees. The average
 direction is computed from the weighted orientation histogram, where a recent
 motion has a larger weight and the motion occurred in the past has a smaller
 weight, as recorded in <code>mhi</code>.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>orientation</code> - Motion gradient orientation image calculated by the
 function "calcMotionGradient".</dd><dd><code>mask</code> - Mask image. It may be a conjunction of a valid gradient mask,
 also calculated by "calcMotionGradient", and the mask of a region whose
 direction needs to be calculated.</dd><dd><code>mhi</code> - Motion history image calculated by "updateMotionHistory".</dd><dd><code>timestamp</code> - Timestamp passed to "updateMotionHistory".</dd><dd><code>duration</code> - Maximum duration of a motion track in milliseconds, passed to
 "updateMotionHistory".</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcglobalorientation">org.opencv.video.Video.calcGlobalOrientation</a></dd></dl>
</li>
</ul>
<a name="calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcMotionGradient</h4>
<pre>public static&nbsp;void&nbsp;calcMotionGradient(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                      double&nbsp;delta1,
                      double&nbsp;delta2)</pre>
<div class="block"><p>Calculates a gradient orientation of a motion history image.</p>

 <p>The function calculates a gradient orientation at each pixel <em>(x, y)</em>
 as:</p>

 <p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>

 <p>In fact, "fastAtan2" and "phase" are used so that the computed angle is
 measured in degrees and covers the full range 0..360. Also, the
 <code>mask</code> is filled to indicate pixels where the computed angle is
 valid.</p>

 <p>Note:</p>
 <ul>
   <li> (Python) An example on how to perform a motion template technique can
 be found at opencv_source_code/samples/python2/motempl.py
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mhi</code> - Motion history single-channel floating-point image.</dd><dd><code>mask</code> - Output mask image that has the type <code>CV_8UC1</code> and the
 same size as <code>mhi</code>. Its non-zero elements mark pixels where the
 motion gradient data is correct.</dd><dd><code>orientation</code> - Output motion gradient orientation image that has the same
 type and the same size as <code>mhi</code>. Each pixel of the image is a
 motion orientation, from 0 to 360 degrees.</dd><dd><code>delta1</code> - Minimal (or maximal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood.</dd><dd><code>delta2</code> - Maximal (or minimal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood. That is, the function
 finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>)
 <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and
 marks the motion orientation at <em>(x, y)</em> as valid only if

 <p><em>min(delta1, delta2) <= M(x,y)-m(x,y) <= max(delta1, delta2).</em></p></dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a></dd></dl>
</li>
</ul>
<a name="calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcMotionGradient</h4>
<pre>public static&nbsp;void&nbsp;calcMotionGradient(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                      double&nbsp;delta1,
                      double&nbsp;delta2,
                      int&nbsp;apertureSize)</pre>
<div class="block"><p>Calculates a gradient orientation of a motion history image.</p>

 <p>The function calculates a gradient orientation at each pixel <em>(x, y)</em>
 as:</p>

 <p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>

 <p>In fact, "fastAtan2" and "phase" are used so that the computed angle is
 measured in degrees and covers the full range 0..360. Also, the
 <code>mask</code> is filled to indicate pixels where the computed angle is
 valid.</p>

 <p>Note:</p>
 <ul>
   <li> (Python) An example on how to perform a motion template technique can
 be found at opencv_source_code/samples/python2/motempl.py
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mhi</code> - Motion history single-channel floating-point image.</dd><dd><code>mask</code> - Output mask image that has the type <code>CV_8UC1</code> and the
 same size as <code>mhi</code>. Its non-zero elements mark pixels where the
 motion gradient data is correct.</dd><dd><code>orientation</code> - Output motion gradient orientation image that has the same
 type and the same size as <code>mhi</code>. Each pixel of the image is a
 motion orientation, from 0 to 360 degrees.</dd><dd><code>delta1</code> - Minimal (or maximal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood.</dd><dd><code>delta2</code> - Maximal (or minimal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood. That is, the function
 finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>)
 <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and
 marks the motion orientation at <em>(x, y)</em> as valid only if

 <p><em>min(delta1, delta2) <= M(x,y)-m(x,y) <= max(delta1, delta2).</em></p></dd><dd><code>apertureSize</code> - Aperture size of the "Sobel" operator.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a></dd></dl>
</li>
</ul>
<a name="calcOpticalFlowFarneback(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, int, double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcOpticalFlowFarneback</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowFarneback(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prev,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;next,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                            double&nbsp;pyr_scale,
                            int&nbsp;levels,
                            int&nbsp;winsize,
                            int&nbsp;iterations,
                            int&nbsp;poly_n,
                            double&nbsp;poly_sigma,
                            int&nbsp;flags)</pre>
<div class="block"><p>Computes a dense optical flow using the Gunnar Farneback's algorithm.</p>

 <p>The function finds an optical flow for each <code>prev</code> pixel using the
 [Farneback2003] algorithm so that</p>

 <p><em>prev(y,x) ~ next(y + flow(y,x)[1], x + flow(y,x)[0])</em></p>

 <p>Note:</p>
 <ul>
   <li> An example using the optical flow algorithm described by Gunnar
 Farneback can be found at opencv_source_code/samples/cpp/fback.cpp
   <li> (Python) An example using the optical flow algorithm described by
 Gunnar Farneback can be found at opencv_source_code/samples/python2/opt_flow.py
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>prev</code> - first 8-bit single-channel input image.</dd><dd><code>next</code> - second input image of the same size and the same type as
 <code>prev</code>.</dd><dd><code>flow</code> - computed flow image that has the same size as <code>prev</code>
 and type <code>CV_32FC2</code>.</dd><dd><code>pyr_scale</code> - parameter, specifying the image scale (<1) to build pyramids
 for each image; <code>pyr_scale=0.5</code> means a classical pyramid, where
 each next layer is twice smaller than the previous one.</dd><dd><code>levels</code> - number of pyramid layers including the initial image;
 <code>levels=1</code> means that no extra layers are created and only the
 original images are used.</dd><dd><code>winsize</code> - averaging window size; larger values increase the algorithm
 robustness to image noise and give more chances for fast motion detection,
 but yield more blurred motion field.</dd><dd><code>iterations</code> - number of iterations the algorithm does at each pyramid
 level.</dd><dd><code>poly_n</code> - size of the pixel neighborhood used to find polynomial
 expansion in each pixel; larger values mean that the image will be
 approximated with smoother surfaces, yielding more robust algorithm and more
 blurred motion field, typically <code>poly_n</code> =5 or 7.</dd><dd><code>poly_sigma</code> - standard deviation of the Gaussian that is used to smooth
 derivatives used as a basis for the polynomial expansion; for
 <code>poly_n=5</code>, you can set <code>poly_sigma=1.1</code>, for
 <code>poly_n=7</code>, a good value would be <code>poly_sigma=1.5</code>.</dd><dd><code>flags</code> - operation flags that can be a combination of the following:
 <ul>
   <li> OPTFLOW_USE_INITIAL_FLOW uses the input <code>flow</code> as an
 initial flow approximation.
   <li> OPTFLOW_FARNEBACK_GAUSSIAN uses the Gaussian <em>winsizexwinsize</em>
 filter instead of a box filter of the same size for optical flow estimation;
 usually, this option gives z more accurate flow than with a box filter, at
 the cost of lower speed; normally, <code>winsize</code> for a Gaussian window
 should be set to a larger value to achieve the same level of robustness.
 </ul></dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowfarneback">org.opencv.video.Video.calcOpticalFlowFarneback</a></dd></dl>
</li>
</ul>
<a name="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcOpticalFlowPyrLK</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowPyrLK(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                        <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err)</pre>
<div class="block"><p>Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</p>

 <p>The function implements a sparse iterative version of the Lucas-Kanade
 optical flow in pyramids. See [Bouguet00]. The function is parallelized with
 the TBB library.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the Lucas-Kanade optical flow algorithm can be found
 at opencv_source_code/samples/cpp/lkdemo.cpp
   <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
 be found at opencv_source_code/samples/python2/lk_track.py
   <li> (Python) An example using the Lucas-Kanade tracker for homography
 matching can be found at opencv_source_code/samples/python2/lk_homography.py
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>prevImg</code> - first 8-bit input image or pyramid constructed by
 "buildOpticalFlowPyramid".</dd><dd><code>nextImg</code> - second input image or pyramid of the same size and the same
 type as <code>prevImg</code>.</dd><dd><code>prevPts</code> - vector of 2D points for which the flow needs to be found;
 point coordinates must be single-precision floating-point numbers.</dd><dd><code>nextPts</code> - output vector of 2D points (with single-precision
 floating-point coordinates) containing the calculated new positions of input
 features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
 is passed, the vector must have the same size as in the input.</dd><dd><code>status</code> - output status vector (of unsigned chars); each element of the
 vector is set to 1 if the flow for the corresponding features has been found,
 otherwise, it is set to 0.</dd><dd><code>err</code> - output vector of errors; each element of the vector is set to an
 error for the corresponding feature, type of the error measure can be set in
 <code>flags</code> parameter; if the flow wasn't found then the error is not
 defined (use the <code>status</code> parameter to find such cases).</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a></dd></dl>
</li>
</ul>
<a name="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcOpticalFlowPyrLK</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowPyrLK(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                        <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
                        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                        int&nbsp;maxLevel)</pre>
<div class="block"><p>Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</p>

 <p>The function implements a sparse iterative version of the Lucas-Kanade
 optical flow in pyramids. See [Bouguet00]. The function is parallelized with
 the TBB library.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the Lucas-Kanade optical flow algorithm can be found
 at opencv_source_code/samples/cpp/lkdemo.cpp
   <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
 be found at opencv_source_code/samples/python2/lk_track.py
   <li> (Python) An example using the Lucas-Kanade tracker for homography
 matching can be found at opencv_source_code/samples/python2/lk_homography.py
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>prevImg</code> - first 8-bit input image or pyramid constructed by
 "buildOpticalFlowPyramid".</dd><dd><code>nextImg</code> - second input image or pyramid of the same size and the same
 type as <code>prevImg</code>.</dd><dd><code>prevPts</code> - vector of 2D points for which the flow needs to be found;
 point coordinates must be single-precision floating-point numbers.</dd><dd><code>nextPts</code> - output vector of 2D points (with single-precision
 floating-point coordinates) containing the calculated new positions of input
 features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
 is passed, the vector must have the same size as in the input.</dd><dd><code>status</code> - output status vector (of unsigned chars); each element of the
 vector is set to 1 if the flow for the corresponding features has been found,
 otherwise, it is set to 0.</dd><dd><code>err</code> - output vector of errors; each element of the vector is set to an
 error for the corresponding feature, type of the error measure can be set in
 <code>flags</code> parameter; if the flow wasn't found then the error is not
 defined (use the <code>status</code> parameter to find such cases).</dd><dd><code>winSize</code> - size of the search window at each pyramid level.</dd><dd><code>maxLevel</code> - 0-based maximal pyramid level number; if set to 0, pyramids
 are not used (single level), if set to 1, two levels are used, and so on; if
 pyramids are passed to input then algorithm will use as many levels as
 pyramids have but no more than <code>maxLevel</code>.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a></dd></dl>
</li>
</ul>
<a name="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcOpticalFlowPyrLK</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowPyrLK(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                        <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
                        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                        int&nbsp;maxLevel,
                        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                        int&nbsp;flags,
                        double&nbsp;minEigThreshold)</pre>
<div class="block"><p>Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</p>

 <p>The function implements a sparse iterative version of the Lucas-Kanade
 optical flow in pyramids. See [Bouguet00]. The function is parallelized with
 the TBB library.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the Lucas-Kanade optical flow algorithm can be found
 at opencv_source_code/samples/cpp/lkdemo.cpp
   <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
 be found at opencv_source_code/samples/python2/lk_track.py
   <li> (Python) An example using the Lucas-Kanade tracker for homography
 matching can be found at opencv_source_code/samples/python2/lk_homography.py
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>prevImg</code> - first 8-bit input image or pyramid constructed by
 "buildOpticalFlowPyramid".</dd><dd><code>nextImg</code> - second input image or pyramid of the same size and the same
 type as <code>prevImg</code>.</dd><dd><code>prevPts</code> - vector of 2D points for which the flow needs to be found;
 point coordinates must be single-precision floating-point numbers.</dd><dd><code>nextPts</code> - output vector of 2D points (with single-precision
 floating-point coordinates) containing the calculated new positions of input
 features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
 is passed, the vector must have the same size as in the input.</dd><dd><code>status</code> - output status vector (of unsigned chars); each element of the
 vector is set to 1 if the flow for the corresponding features has been found,
 otherwise, it is set to 0.</dd><dd><code>err</code> - output vector of errors; each element of the vector is set to an
 error for the corresponding feature, type of the error measure can be set in
 <code>flags</code> parameter; if the flow wasn't found then the error is not
 defined (use the <code>status</code> parameter to find such cases).</dd><dd><code>winSize</code> - size of the search window at each pyramid level.</dd><dd><code>maxLevel</code> - 0-based maximal pyramid level number; if set to 0, pyramids
 are not used (single level), if set to 1, two levels are used, and so on; if
 pyramids are passed to input then algorithm will use as many levels as
 pyramids have but no more than <code>maxLevel</code>.</dd><dd><code>criteria</code> - parameter, specifying the termination criteria of the
 iterative search algorithm (after the specified maximum number of iterations
 <code>criteria.maxCount</code> or when the search window moves by less than
 <code>criteria.epsilon</code>.</dd><dd><code>flags</code> - operation flags:
 <ul>
   <li> OPTFLOW_USE_INITIAL_FLOW uses initial estimations, stored in
 <code>nextPts</code>; if the flag is not set, then <code>prevPts</code> is
 copied to <code>nextPts</code> and is considered the initial estimate.
   <li> OPTFLOW_LK_GET_MIN_EIGENVALS use minimum eigen values as an error
 measure (see <code>minEigThreshold</code> description); if the flag is not
 set, then L1 distance between patches around the original and a moved point,
 divided by number of pixels in a window, is used as a error measure.
 </ul></dd><dd><code>minEigThreshold</code> - the algorithm calculates the minimum eigen value of a
 2x2 normal matrix of optical flow equations (this matrix is called a spatial
 gradient matrix in [Bouguet00]), divided by number of pixels in a window; if
 this value is less than <code>minEigThreshold</code>, then a corresponding
 feature is filtered out and its flow is not processed, so it allows to remove
 bad points and get a performance boost.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a></dd></dl>
</li>
</ul>
<a name="calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcOpticalFlowSF</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowSF(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                     int&nbsp;layers,
                     int&nbsp;averaging_block_size,
                     int&nbsp;max_flow)</pre>
<div class="block"><p>Calculate an optical flow using "SimpleFlow" algorithm.</p>

 <p>See [Tao2012]. And site of project - http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the simpleFlow algorithm can be found at
 opencv_source_code/samples/cpp/simpleflow_demo.cpp
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>from</code> - a from</dd><dd><code>to</code> - a to</dd><dd><code>flow</code> - a flow</dd><dd><code>layers</code> - Number of layers</dd><dd><code>averaging_block_size</code> - Size of block through which we sum up when
 calculate cost function for pixel</dd><dd><code>max_flow</code> - maximal flow that we search at each level</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a></dd></dl>
</li>
</ul>
<a name="calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int, double, double, double, int, double, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcOpticalFlowSF</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowSF(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                     int&nbsp;layers,
                     int&nbsp;averaging_block_size,
                     int&nbsp;max_flow,
                     double&nbsp;sigma_dist,
                     double&nbsp;sigma_color,
                     int&nbsp;postprocess_window,
                     double&nbsp;sigma_dist_fix,
                     double&nbsp;sigma_color_fix,
                     double&nbsp;occ_thr,
                     int&nbsp;upscale_averaging_radius,
                     double&nbsp;upscale_sigma_dist,
                     double&nbsp;upscale_sigma_color,
                     double&nbsp;speed_up_thr)</pre>
<div class="block"><p>Calculate an optical flow using "SimpleFlow" algorithm.</p>

 <p>See [Tao2012]. And site of project - http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the simpleFlow algorithm can be found at
 opencv_source_code/samples/cpp/simpleflow_demo.cpp
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>from</code> - a from</dd><dd><code>to</code> - a to</dd><dd><code>flow</code> - a flow</dd><dd><code>layers</code> - Number of layers</dd><dd><code>averaging_block_size</code> - Size of block through which we sum up when
 calculate cost function for pixel</dd><dd><code>max_flow</code> - maximal flow that we search at each level</dd><dd><code>sigma_dist</code> - vector smooth spatial sigma parameter</dd><dd><code>sigma_color</code> - vector smooth color sigma parameter</dd><dd><code>postprocess_window</code> - window size for postprocess cross bilateral filter</dd><dd><code>sigma_dist_fix</code> - spatial sigma for postprocess cross bilateralf filter</dd><dd><code>sigma_color_fix</code> - color sigma for postprocess cross bilateral filter</dd><dd><code>occ_thr</code> - threshold for detecting occlusions</dd><dd><code>upscale_averaging_radius</code> - a upscale_averaging_radius</dd><dd><code>upscale_sigma_dist</code> - spatial sigma for bilateral upscale operation</dd><dd><code>upscale_sigma_color</code> - color sigma for bilateral upscale operation</dd><dd><code>speed_up_thr</code> - threshold to detect point with irregular flow - where
 flow should be recalculated after upscale</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a></dd></dl>
</li>
</ul>
<a name="CamShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CamShift</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;CamShift(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;probImage,
                   <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
                   <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block"><p>Finds an object center, size, and orientation.</p>

 <p>The function implements the CAMSHIFT object tracking algorithm [Bradski98].
 First, it finds an object center using "meanShift" and then adjusts the
 window size and finds the optimal rotation. The function returns the rotated
 rectangle structure that includes the object position, size, and orientation.
 The next position of the search window can be obtained with <code>RotatedRect.boundingRect()</code>.</p>

 <p>See the OpenCV sample <code>camshiftdemo.c</code> that tracks colored
 objects.</p>

 <p>Note:</p>
 <ul>
   <li> (Python) A sample explaining the camshift tracking algorithm can be
 found at opencv_source_code/samples/python2/camshift.py
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>probImage</code> - Back projection of the object histogram. See
 "calcBackProject".</dd><dd><code>window</code> - Initial search window.</dd><dd><code>criteria</code> - Stop criteria for the underlying "meanShift".

 <p>:returns: (in old interfaces) Number of iterations CAMSHIFT took to converge</p></dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#camshift">org.opencv.video.Video.CamShift</a></dd></dl>
</li>
</ul>
<a name="estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateRigidTransform</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateRigidTransform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         boolean&nbsp;fullAffine)</pre>
<div class="block"><p>Computes an optimal affine transformation between two 2D point sets.</p>

 <p>The function finds an optimal affine transform *[A|b]* (a <code>2 x 3</code>
 floating-point matrix) that approximates best the affine transformation
 between:</p>
 <ul>
   <li> Two point sets
   <li> Two raster images. In this case, the function first finds some
 features in the <code>src</code> image and finds the corresponding features
 in <code>dst</code> image. After that, the problem is reduced to the first
 case.
 </ul>

 <p>In case of point sets, the problem is formulated as follows: you need to find
 a 2x2 matrix *A* and 2x1 vector *b* so that:</p>

 <p><em>[A^*|b^*] = arg min _([A|b]) sum _i|dst[i] - A (src[i])^T - b| ^2</em></p>

 <p>where <code>src[i]</code> and <code>dst[i]</code> are the i-th points in
 <code>src</code> and <code>dst</code>, respectively</p>

 <p><em>[A|b]</em> can be either arbitrary (when <code>fullAffine=true</code>) or
 have a form of</p>

 <p><em>a_11 a_12 b_1
 -a_12 a_11 b_2 </em></p>

 <p>when <code>fullAffine=false</code>.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>src</code> - First input 2D point set stored in <code>std.vector</code> or
 <code>Mat</code>, or an image stored in <code>Mat</code>.</dd><dd><code>dst</code> - Second input 2D point set of the same size and the same type as
 <code>A</code>, or another image.</dd><dd><code>fullAffine</code> - If true, the function finds an optimal affine
 transformation with no additional restrictions (6 degrees of freedom).
 Otherwise, the class of transformations to choose from is limited to
 combinations of translation, rotation, and uniform scaling (5 degrees of
 freedom).</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#estimaterigidtransform">org.opencv.video.Video.estimateRigidTransform</a>, 
<a href="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)"><code>Calib3d.findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)</code></a>, 
<a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><code>Imgproc.getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)</code></a>, 
<a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd></dl>
</li>
</ul>
<a name="meanShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>meanShift</h4>
<pre>public static&nbsp;int&nbsp;meanShift(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;probImage,
            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block"><p>Finds an object on a back projection image.</p>

 <p>The function implements the iterative object search algorithm. It takes the
 input back projection of an object and the initial position. The mass center
 in <code>window</code> of the back projection image is computed and the
 search window center shifts to the mass center. The procedure is repeated
 until the specified number of iterations <code>criteria.maxCount</code> is
 done or until the window center shifts by less than <code>criteria.epsilon</code>.
 The algorithm is used inside "CamShift" and, unlike "CamShift", the search
 window size or orientation do not change during the search. You can simply
 pass the output of "calcBackProject" to this function. But better results can
 be obtained if you pre-filter the back projection and remove the noise. For
 example, you can do this by retrieving connected components with
 "findContours", throwing away contours with small area ("contourArea"), and
 rendering the remaining contours with "drawContours".</p>

 <p>Note:</p>
 <ul>
   <li> A mean-shift tracking sample can be found at opencv_source_code/samples/cpp/camshiftdemo.cpp
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>probImage</code> - Back projection of the object histogram. See
 "calcBackProject" for details.</dd><dd><code>window</code> - Initial search window.</dd><dd><code>criteria</code> - Stop criteria for the iterative search algorithm.

 <p>:returns: Number of iterations CAMSHIFT took to converge.</p></dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#meanshift">org.opencv.video.Video.meanShift</a></dd></dl>
</li>
</ul>
<a name="segmentMotion(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfRect, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>segmentMotion</h4>
<pre>public static&nbsp;void&nbsp;segmentMotion(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;segmask,
                 <a href="../../../org/opencv/core/MatOfRect.html" title="class in org.opencv.core">MatOfRect</a>&nbsp;boundingRects,
                 double&nbsp;timestamp,
                 double&nbsp;segThresh)</pre>
<div class="block"><p>Splits a motion history image into a few parts corresponding to separate
 independent motions (for example, left hand, right hand).</p>

 <p>The function finds all of the motion segments and marks them in
 <code>segmask</code> with individual values (1,2,...). It also computes a
 vector with ROIs of motion connected components. After that the motion
 direction for every component can be calculated with "calcGlobalOrientation"
 using the extracted mask of the particular component.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mhi</code> - Motion history image.</dd><dd><code>segmask</code> - Image where the found mask should be stored, single-channel,
 32-bit floating-point.</dd><dd><code>boundingRects</code> - Vector containing ROIs of motion connected components.</dd><dd><code>timestamp</code> - Current time in milliseconds or other units.</dd><dd><code>segThresh</code> - Segmentation threshold that is recommended to be equal to
 the interval between motion history "steps" or greater.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#segmentmotion">org.opencv.video.Video.segmentMotion</a></dd></dl>
</li>
</ul>
<a name="updateMotionHistory(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>updateMotionHistory</h4>
<pre>public static&nbsp;void&nbsp;updateMotionHistory(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;silhouette,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                       double&nbsp;timestamp,
                       double&nbsp;duration)</pre>
<div class="block"><p>Updates the motion history image by a moving silhouette.</p>

 <p>The function updates the motion history image as follows:</p>

 <p><em>mhi(x,y)= timestamp if silhouette(x,y) != 0; 0 if silhouette(x,y) = 0 and
 mhi &lt(timestamp - duration); mhi(x,y) otherwise</em></p>

 <p>That is, MHI pixels where the motion occurs are set to the current
 <code>timestamp</code>, while the pixels where the motion happened last time
 a long time ago are cleared.</p>

 <p>The function, together with "calcMotionGradient" and "calcGlobalOrientation",
 implements a motion templates technique described in [Davis97] and
 [Bradski00].
 See also the OpenCV sample <code>motempl.c</code> that demonstrates the use
 of all the motion template functions.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>silhouette</code> - Silhouette mask that has non-zero pixels where the motion
 occurs.</dd><dd><code>mhi</code> - Motion history image that is updated by the function
 (single-channel, 32-bit floating-point).</dd><dd><code>timestamp</code> - Current time in milliseconds or other units.</dd><dd><code>duration</code> - Maximal duration of the motion track in the same units as
 <code>timestamp</code>.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#updatemotionhistory">org.opencv.video.Video.updateMotionHistory</a></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em><a href=http://docs.opencv.org>OpenCV 2.4.10 Documentation</a></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/opencv/video/KalmanFilter.html" title="class in org.opencv.video"><span class="strong">PREV CLASS</span></a></li>
<li>NEXT CLASS</li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/video/Video.html" target="_top">FRAMES</a></li>
<li><a href="Video.html" target="_top">NO FRAMES</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>SUMMARY:&nbsp;</li>
<li>NESTED&nbsp;|&nbsp;</li>
<li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">METHOD</a></li>
</ul>
<ul class="subNavList">
<li>DETAIL:&nbsp;</li>
<li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">METHOD</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
